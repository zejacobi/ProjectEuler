"""
# Problem 44: Pentagon numbers

Pentagonal numbers are generated by the formula, P_n=n(3n−1)/2. The first ten pentagonal numbers are:

1, 5, 12, 22, 35, 51, 70, 92, 117, 145, ...

It can be seen that P_4 + P_7 = 22 + 70 = 92 = P_8. However, their difference, 70 − 22 = 48, is not
pentagonal.

Find the pair of pentagonal numbers, P_j and P_k, for which their sum and difference are pentagonal
and D = |P_k − P_j| is minimised; what is the value of D?
"""

# Well luckily the first pair we find should tell us when to stop; as soon as the difference between
# one number and the next is greater than our current D, we should stop.


def make_pentagon(pen):
    return int(pen * (3 * pen - 1) / 2)


# okay, this is ugly and O(n!), but it gets the job done? I'm really not sure what heuristic I could
# have used here.

best = 100000000000000000000000000000000000000000  # arbitrarily big
n = 1
pentagons = [make_pentagon(n)]
supplementary_pentagons = [make_pentagon(3)]
n += 1
supplementary_pentagons_old = [make_pentagon(n)]
for new_pentagon in supplementary_pentagons_old:
    max_pentagon_needed = new_pentagon + pentagons[-1]

    while len(supplementary_pentagons) == 0 or supplementary_pentagons[-1] < max_pentagon_needed:
        n += 1
        supplementary_pentagons.append(make_pentagon(n))

    for pentagon in pentagons:
        if (((new_pentagon - pentagon) in pentagons or
            (new_pentagon - pentagon) in supplementary_pentagons) and
            ((new_pentagon + pentagon) in pentagons or
             (new_pentagon + pentagon) in supplementary_pentagons)):
            if (new_pentagon - pentagon) < best:
                best = new_pentagon - pentagon
                print(best)  # could wait for it to terminate or could just use this.

    pentagons.append(new_pentagon)
    if (pentagons[-1] - pentagons[-2]) > best:
        print(best)
        exit()

    supplementary_pentagons_old.append(supplementary_pentagons.pop(0))
